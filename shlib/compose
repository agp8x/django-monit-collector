#!/bin/sh

RUN=docker-compose.yml

function monitcollector() {
  local src="./src"
  python_dockerfile Dockerfile.generic Dockerfile ${src}
cat <<-EOF
  monitcollector:
    build:
      context: ${src}
      dockerfile: Dockerfile
    image: monitcollector
    volumes:
      - ./src:/usr/src/app
EOF
}

function monitcollector_env(){
cat <<-EOF
    environment:
      - ADMIN=${ADMIN}
      - ADMIN_PWD=${PASSWD}
      - EMAIL=${EMAIL}
EOF
}

function monit() {
  local src="./monit"
  alpine_dockerfile Dockerfile.generic Dockerfile ${src}
  cat <<-EOF
  monit:
    build:
      context: ${src}
      dockerfile: Dockerfile
    image: monit
    privileged: True
    network_mode: "host"
    volumes:
      - ./monit/basic:/etc/monit/monitrc.d/basic
EOF
}

function deployyml() {
  local RUN="${1}"
  local db="./postgres"
  alpine_dockerfile Dockerfile.generic Dockerfile ${db}
  local caddy="./caddy"
  alpine_dockerfile Dockerfile.generic Dockerfile ${caddy}
cat<<-EOF > "${RUN}"
version: '3'

volumes:
  static:
    driver: local
  pgdata:
    driver: local

networks:
  backend:
    driver: bridge
  internal:
    driver: bridge

services:
  db:
    build:
      context: ${db}
      dockerfile: Dockerfile
    image: postgres
    restart: always
    volumes:
      - pgdata:/var/lib/postgresql/data
    expose:
      - 5432
    networks:
      - internal
    environment:
      - POSTGRES_DB=pymonit

$(monitcollector)
      - static:/usr/src/app/static
    depends_on:
      - db
$(monitcollector_env)
      - DECOUPLE_DB=postgresql://postgres:postgres@db/pymonit
      - LISTEN_PORT=8000
    expose:
      - 8000
    networks:
      - internal
    entrypoint: ["dockerize", "-wait", "tcp://db:5432", "gunicornup.sh"]

$(monit)
    environment:
      - MMONIT_URL=http://localhost/monitcollector/collector
    entrypoint: ["dockerize", "-wait", "http://localhost:80", "-timeout", "300s", "/bin/bash","-c","/etc/monit/monit-start.sh"]

  caddy:
    build:
      context: ${caddy}
      dockerfile: Dockerfile
    image: caddy
    restart: always
    networks:
      - internal
      - backend
    volumes:
      - static:/var/www/html/static
      - ./caddy/Caddyfile:/etc/Caddyfile
    ports:
      - "80:80"
EOF
}

function developyml() {
  local RUN="${1}"

cat<<-EOF > "${RUN}"
version: '2'

volumes:
  sqlitedb:
    driver: local

services:
$(monitcollector)
      - sqlitedb:/usr/src/app/data
    environment:
      - LISTEN_PORT=8000
    ports:
      - "8000:8000"

$(monit)
    environment:
      - MMONIT_URL=http://localhost:8000/monitcollector/collector
    entrypoint: ["dockerize", "-wait", "http://localhost:8000", "-timeout", "300s", "/bin/bash","-c","/etc/monit/monit-start.sh"]
EOF
}


function start() {
  local yml="${1}"
  local simple="${2}"
  local created="${3}"
  local orgdir="${PWD##*/}"
  local dir="${orgdir//[-]/}"
  local service=monitcollector
  local name="${dir}_${service}_1"

  if [[ "$simple" == "false" ]]; then
    waitedSleep "PostgreSQL init process complete; ready for start up" "db" "${yml}"
    evaluate_result $? " Started service db"
  fi
#  waitedSleep "static files copied" "${service}" "${yml}"
#  evaluate_result $? " Started service ${service}"
  docker-compose -f "${yml}" up -d

  info "To stop the container again execute"
  info "docker-compose down -v"
}

function waitedSleep() {
  local finished="$1"
  local service="$2"
  local yml="$3"
  local seconds=1
  local rc=0

  docker-compose -f "${yml}" up -d "${service}"
  while true; do
    docker-compose -f "${yml}" logs "${service}" | grep "${finished}" &> /dev/null
    if [ $? == 0 ]; then
      break
    elif ((seconds < ${TIMEOUT})); then
        waiting "${seconds}" "for "${service}" to be ready\e[0m"
        seconds=$((seconds+1))
    else
        rc=1
        break
    fi
  done
  return $rc
}
